{"2":{"1":[{"1":"selenium-webdriver/lib/promise","5":{"1":"lib/promise.js","2":3363,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3363"},"6":{"1":[{"1":"CancellationError","2":"promise_exports_CancellationError.html","3":{"1":[{"2":"<p>Error used when the computation of a promise is cancelled.</p>\n"}]}},{"1":"ControlFlow","2":"promise_exports_ControlFlow.html","3":{"1":[{"2":"<p>Handles the execution of scheduled tasks, each of which may be an\nasynchronous operation.</p>\n"}]}},{"1":"Deferred","2":"promise_exports_Deferred.html","3":{"1":[{"2":"<p>Represents a value that will be resolved at some point in the future.</p>\n"}]}},{"1":"MultipleUnhandledRejectionError","2":"promise_exports_MultipleUnhandledRejectionError.html","3":{"1":[{"2":"<p>Error used when there are multiple unhandled promise rejections detected\nwithin a task or callback.</p>\n"}]}},{"1":"Promise","2":"promise_exports_Promise.html","3":{"1":[{"2":"<p>Represents the eventual value of a completed operation.</p>\n"}]}}],"3":[{"1":"CancellableThenable","2":"promise_exports_CancellableThenable.html","3":{"1":[{"2":"<p>Marker interface for objects that allow consumers to request the cancellation\nof a promise-based operation.</p>\n"}]},"4":{"5":true}},{"1":"Resolver","2":"promise_exports_Resolver.html","3":{"1":[{"2":"<p>Structural interface for a deferred promise resolver.</p>\n"}]},"4":{"5":true}},{"1":"Scheduler","2":"promise_exports_Scheduler.html","3":{"1":[{"2":"<p>Defines methods for coordinating the execution of asynchronous tasks.</p>\n"}]},"4":{"5":true}},{"1":"Thenable","2":"promise_exports_Thenable.html","3":{"1":[{"2":"<p>Thenable is a promise-like object with a <code>then</code> method which may be\nused to schedule callbacks on a promised value.</p>\n"}]},"4":{"5":true}}]},"7":{"1":[{"2":"<blockquote>\n<h3>IMPORTANT NOTICE</h3>\n<p>The promise manager contained in this module is in the process of being\nphased out in favor of native JavaScript promises. This will be a long\nprocess and will not be completed until there have been two major LTS Node\nreleases (approx. Node v10.0) that support\n<a href=\"https://tc39.github.io/ecmascript-asyncawait/\">async functions</a>.</p>\n<p>At this time, the promise manager can be disabled by setting an environment\nvariable, <code>SELENIUM_PROMISE_MANAGER&#61;0</code>. In the absence of async functions,\nusers may use generators with the\n<a href=\"promise.html#consume\"><code>promise.consume()</code></a> function to write &#34;synchronous&#34;\nstyle tests:</p>\n<pre><code class=\"language-js\">const {Builder, By, promise, until} &#61; require(&#39;selenium-webdriver&#39;);\n\nlet result &#61; promise.consume(function* doGoogleSearch() {\n  let driver &#61; new Builder().forBrowser(&#39;firefox&#39;).build();\n  yield driver.get(&#39;http://www.google.com/ncr&#39;);\n  yield driver.findElement(By.name(&#39;q&#39;)).sendKeys(&#39;webdriver&#39;);\n  yield driver.findElement(By.name(&#39;btnG&#39;)).click();\n  yield driver.wait(until.titleIs(&#39;webdriver - Google Search&#39;), 1000);\n  yield driver.quit();\n});\n\nresult.then(_ &#61;&gt; console.log(&#39;SUCCESS!&#39;),\n            e &#61;&gt; console.error(&#39;FAILURE: &#39; &#43; e));\n</code></pre>\n<p>The motivation behind this change and full deprecation plan are documented\nin <a href=\"https://github.com/SeleniumHQ/selenium/issues/2969\">issue 2969</a>.</p>\n</blockquote>\n<p>The promise module is centered around the <a href=\"promise_exports_ControlFlow.html\">ControlFlow</a>, a class\nthat coordinates the execution of asynchronous tasks. The ControlFlow allows\nusers to focus on the imperative commands for their script without worrying\nabout chaining together every single asynchronous action, which can be\ntedious and verbose. APIs may be layered on top of the control flow to read\nas if they were synchronous. For instance, the core\n<a href=\"webdriver_exports_WebDriver.html\">WebDriver</a> API is built on top of the\ncontrol flow, allowing users to write</p>\n<pre><code> driver.get(&#39;http://www.google.com/ncr&#39;);\n driver.findElement({name: &#39;q&#39;}).sendKeys(&#39;webdriver&#39;);\n driver.findElement({name: &#39;btnGn&#39;}).click();\n</code></pre>\n<p>instead of</p>\n<pre><code> driver.get(&#39;http://www.google.com/ncr&#39;)\n .then(function() {\n   return driver.findElement({name: &#39;q&#39;});\n })\n .then(function(q) {\n   return q.sendKeys(&#39;webdriver&#39;);\n })\n .then(function() {\n   return driver.findElement({name: &#39;btnG&#39;});\n })\n .then(function(btnG) {\n   return btnG.click();\n });\n</code></pre>\n<h2>Tasks and Task Queues</h2>\n<p>The control flow is based on the concept of tasks and task queues. Tasks are\nfunctions that define the basic unit of work for the control flow to execute.\nEach task is scheduled via <a href=\"promise_exports_ControlFlow.html#execute\"><code>ControlFlow#execute()</code></a>, which will return\na <a href=\"promise_exports_Promise.html\"><code>ManagedPromise</code></a> that will be resolved with the task&#39;s result.</p>\n<p>A task queue contains all of the tasks scheduled within a single turn of the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">JavaScript event loop</a>. The control flow will create a new task queue\nthe first time a task is scheduled within an event loop.</p>\n<pre><code> var flow &#61; promise.controlFlow();\n flow.execute(foo);       // Creates a new task queue and inserts foo.\n flow.execute(bar);       // Inserts bar into the same queue as foo.\n setTimeout(function() {\n   flow.execute(baz);     // Creates a new task queue and inserts baz.\n }, 0);\n</code></pre>\n<p>Whenever the control flow creates a new task queue, it will automatically\nbegin executing tasks in the next available turn of the event loop. This\nexecution is <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">scheduled as a microtask</a> like e.g. a\n(native) <code>Promise.then()</code> callback.</p>\n<pre><code> setTimeout(() &#61;&gt; console.log(&#39;a&#39;));\n Promise.resolve().then(() &#61;&gt; console.log(&#39;b&#39;));  // A native promise.\n flow.execute(() &#61;&gt; console.log(&#39;c&#39;));\n Promise.resolve().then(() &#61;&gt; console.log(&#39;d&#39;));\n setTimeout(() &#61;&gt; console.log(&#39;fin&#39;));\n // b\n // c\n // d\n // a\n // fin\n</code></pre>\n<p>In the example above, b/c/d is logged before a/fin because native promises\nand this module use &#34;microtask&#34; timers, which have a higher priority than\n&#34;macrotasks&#34; like <code>setTimeout</code>.</p>\n<h2>Task Execution</h2>\n<p>Upon creating a task queue, and whenever an existing queue completes a task,\nthe control flow will schedule a microtask timer to process any scheduled\ntasks. This ensures no task is ever started within the same turn of the\nJavaScript event loop in which it was scheduled, nor is a task ever started\nwithin the same turn that another finishes.</p>\n<p>When the execution timer fires, a single task will be dequeued and executed.\nThere are several important events that may occur while executing a task\nfunction:</p>\n<ol><li>A new task queue is created by a call to <a href=\"promise_exports_ControlFlow.html#execute\"><code>ControlFlow#execute()</code></a>.\nAny tasks scheduled within this task queue are considered subtasks of the\ncurrent task.</li><li>The task function throws an error. Any scheduled tasks are immediately\ndiscarded and the task&#39;s promised result (previously returned by\n<a href=\"promise_exports_ControlFlow.html#execute\"><code>ControlFlow#execute()</code></a>) is immediately rejected with the thrown\nerror.</li><li>The task function returns successfully.</li></ol>\n<p>If a task function created a new task queue, the control flow will wait for\nthat queue to complete before processing the task result. If the queue\ncompletes without error, the flow will settle the task&#39;s promise with the\nvalue originally returned by the task function. On the other hand, if the task\nqueue terminates with an error, the task&#39;s promise will be rejected with that\nerror.</p>\n<pre><code> flow.execute(function() {\n   flow.execute(() &#61;&gt; console.log(&#39;a&#39;));\n   flow.execute(() &#61;&gt; console.log(&#39;b&#39;));\n });\n flow.execute(() &#61;&gt; console.log(&#39;c&#39;));\n // a\n // b\n // c\n</code></pre>\n<h2>ManagedPromise Integration</h2>\n<p>In addition to the <a href=\"promise_exports_ControlFlow.html\"><code>ControlFlow</code></a> class, the promise module also exports\na <a href=\"https://promisesaplus.com/\">Promises/A&#43;</a> <a href=\"promise_exports_Promise.html\">implementation</a> that is deeply\nintegrated with the ControlFlow. First and foremost, each promise\n<a href=\"promise_exports_Promise.html#then\">callback</a> is scheduled with the\ncontrol flow as a task. As a result, each callback is invoked in its own turn\nof the JavaScript event loop with its own task queue. If any tasks are\nscheduled within a callback, the callback&#39;s promised result will not be\nsettled until the task queue has completed.</p>\n<pre><code> promise.fulfilled().then(function() {\n   flow.execute(function() {\n     console.log(&#39;b&#39;);\n   });\n }).then(() &#61;&gt; console.log(&#39;a&#39;));\n // b\n // a\n</code></pre>\n<h3>Scheduling ManagedPromise Callbacks <a id=\"scheduling_callbacks\"></a></h3>\n<p>How callbacks are scheduled in the control flow depends on when they are\nattached to the promise. Callbacks attached to a <em>previously</em> resolved\npromise are immediately enqueued as subtasks of the currently running task.</p>\n<pre><code> var p &#61; promise.fulfilled();\n flow.execute(function() {\n   flow.execute(() &#61;&gt; console.log(&#39;A&#39;));\n   p.then(      () &#61;&gt; console.log(&#39;B&#39;));\n   flow.execute(() &#61;&gt; console.log(&#39;C&#39;));\n   p.then(      () &#61;&gt; console.log(&#39;D&#39;));\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // A\n // B\n // C\n // D\n // fin\n</code></pre>\n<p>When a promise is resolved while a task function is on the call stack, any\ncallbacks also registered in that stack frame are scheduled as if the promise\nwere already resolved:</p>\n<pre><code> var d &#61; promise.defer();\n flow.execute(function() {\n   flow.execute(  () &#61;&gt; console.log(&#39;A&#39;));\n   d.promise.then(() &#61;&gt; console.log(&#39;B&#39;));\n   flow.execute(  () &#61;&gt; console.log(&#39;C&#39;));\n   d.promise.then(() &#61;&gt; console.log(&#39;D&#39;));\n\n   d.fulfill();\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // A\n // B\n // C\n // D\n // fin\n</code></pre>\n<p>Callbacks attached to an <em>unresolved</em> promise within a task function are\nonly weakly scheduled as subtasks and will be dropped if they reach the\nfront of the queue before the promise is resolved. In the example below, the\ncallbacks for <code>B</code> &amp; <code>D</code> are dropped as sub-tasks since they are attached to\nan unresolved promise when they reach the front of the task queue.</p>\n<pre><code> var d &#61; promise.defer();\n flow.execute(function() {\n   flow.execute(  () &#61;&gt; console.log(&#39;A&#39;));\n   d.promise.then(() &#61;&gt; console.log(&#39;B&#39;));\n   flow.execute(  () &#61;&gt; console.log(&#39;C&#39;));\n   d.promise.then(() &#61;&gt; console.log(&#39;D&#39;));\n\n   setTimeout(d.fulfill, 20);\n }).then(function() {\n   console.log(&#39;fin&#39;)\n });\n // A\n // C\n // fin\n // B\n // D\n</code></pre>\n<p>If a promise is resolved while a task function is on the call stack, any\npreviously registered and unqueued callbacks (i.e. either attached while no\ntask was on the call stack, or previously dropped as described above) act as\n<em>interrupts</em> and are inserted at the front of the task queue. If multiple\npromises are fulfilled, their interrupts are enqueued in the order the\npromises are resolved.</p>\n<pre><code> var d1 &#61; promise.defer();\n d1.promise.then(() &#61;&gt; console.log(&#39;A&#39;));\n\n var d2 &#61; promise.defer();\n d2.promise.then(() &#61;&gt; console.log(&#39;B&#39;));\n\n flow.execute(function() {\n   d1.promise.then(() &#61;&gt; console.log(&#39;C&#39;));\n   flow.execute(() &#61;&gt; console.log(&#39;D&#39;));\n });\n flow.execute(function() {\n   flow.execute(() &#61;&gt; console.log(&#39;E&#39;));\n   flow.execute(() &#61;&gt; console.log(&#39;F&#39;));\n   d1.fulfill();\n   d2.fulfill();\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // D\n // A\n // C\n // B\n // E\n // F\n // fin\n</code></pre>\n<p>Within a task function (or callback), each step of a promise chain acts as\nan interrupt on the task queue:</p>\n<pre><code> var d &#61; promise.defer();\n flow.execute(function() {\n   d.promise.\n       then(() &#61;&gt; console.log(&#39;A&#39;)).\n       then(() &#61;&gt; console.log(&#39;B&#39;)).\n       then(() &#61;&gt; console.log(&#39;C&#39;)).\n       then(() &#61;&gt; console.log(&#39;D&#39;));\n\n   flow.execute(() &#61;&gt; console.log(&#39;E&#39;));\n   d.fulfill();\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // A\n // B\n // C\n // D\n // E\n // fin\n</code></pre>\n<p>If there are multiple promise chains derived from a single promise, they are\nprocessed in the order created:</p>\n<pre><code> var d &#61; promise.defer();\n flow.execute(function() {\n   var chain &#61; d.promise.then(() &#61;&gt; console.log(&#39;A&#39;));\n\n   chain.then(() &#61;&gt; console.log(&#39;B&#39;)).\n       then(() &#61;&gt; console.log(&#39;C&#39;));\n\n   chain.then(() &#61;&gt; console.log(&#39;D&#39;)).\n       then(() &#61;&gt; console.log(&#39;E&#39;));\n\n   flow.execute(() &#61;&gt; console.log(&#39;F&#39;));\n\n   d.fulfill();\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // A\n // B\n // C\n // D\n // E\n // F\n // fin\n</code></pre>\n<p>Even though a subtask&#39;s promised result will never resolve while the task\nfunction is on the stack, it will be treated as a promise resolved within the\ntask. In all other scenarios, a task&#39;s promise behaves just like a normal\npromise. In the sample below, <code>C/D</code> is logged before <code>B</code> because the\nresolution of <code>subtask1</code> interrupts the flow of the enclosing task. Within\nthe final subtask, <code>E/F</code> is logged in order because <code>subtask1</code> is a resolved\npromise when that task runs.</p>\n<pre><code> flow.execute(function() {\n   var subtask1 &#61; flow.execute(() &#61;&gt; console.log(&#39;A&#39;));\n   var subtask2 &#61; flow.execute(() &#61;&gt; console.log(&#39;B&#39;));\n\n   subtask1.then(() &#61;&gt; console.log(&#39;C&#39;));\n   subtask1.then(() &#61;&gt; console.log(&#39;D&#39;));\n\n   flow.execute(function() {\n     flow.execute(() &#61;&gt; console.log(&#39;E&#39;));\n     subtask1.then(() &#61;&gt; console.log(&#39;F&#39;));\n   });\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // A\n // C\n // D\n // B\n // E\n // F\n // fin\n</code></pre>\n<p>Finally, consider the following:</p>\n<pre><code> var d &#61; promise.defer();\n d.promise.then(() &#61;&gt; console.log(&#39;A&#39;));\n d.promise.then(() &#61;&gt; console.log(&#39;B&#39;));\n\n flow.execute(function() {\n   flow.execute(  () &#61;&gt; console.log(&#39;C&#39;));\n   d.promise.then(() &#61;&gt; console.log(&#39;D&#39;));\n\n   flow.execute(  () &#61;&gt; console.log(&#39;E&#39;));\n   d.promise.then(() &#61;&gt; console.log(&#39;F&#39;));\n\n   d.fulfill();\n\n   flow.execute(  () &#61;&gt; console.log(&#39;G&#39;));\n   d.promise.then(() &#61;&gt; console.log(&#39;H&#39;));\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // A\n // B\n // C\n // D\n // E\n // F\n // G\n // H\n // fin\n</code></pre>\n<p>In this example, callbacks are registered on <code>d.promise</code> both before and\nduring the invocation of the task function. When <code>d.fulfill()</code> is called,\nthe callbacks registered before the task (<code>A</code> &amp; <code>B</code>) are registered as\ninterrupts. The remaining callbacks were all attached within the task and\nare scheduled in the flow as standard tasks.</p>\n<h2>Generator Support</h2>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\">Generators</a> may be scheduled as tasks within a control flow or attached\nas callbacks to a promise. Each time the generator yields a promise, the\ncontrol flow will wait for that promise to settle before executing the next\niteration of the generator. The yielded promise&#39;s fulfilled value will be\npassed back into the generator:</p>\n<pre><code> flow.execute(function* () {\n   var d &#61; promise.defer();\n\n   setTimeout(() &#61;&gt; console.log(&#39;...waiting...&#39;), 25);\n   setTimeout(() &#61;&gt; d.fulfill(123), 50);\n\n   console.log(&#39;start: &#39; &#43; Date.now());\n\n   var value &#61; yield d.promise;\n   console.log(&#39;mid: %d; value &#61; %d&#39;, Date.now(), value);\n\n   yield promise.delayed(10);\n   console.log(&#39;end: &#39; &#43; Date.now());\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // start: 0\n // ...waiting...\n // mid: 50; value &#61; 123\n // end: 60\n // fin\n</code></pre>\n<p>Yielding the result of a promise chain will wait for the entire chain to\ncomplete:</p>\n<pre><code> promise.fulfilled().then(function* () {\n   console.log(&#39;start: &#39; &#43; Date.now());\n\n   var value &#61; yield flow.\n       execute(() &#61;&gt; console.log(&#39;A&#39;)).\n       then(   () &#61;&gt; console.log(&#39;B&#39;)).\n       then(   () &#61;&gt; 123);\n\n   console.log(&#39;mid: %s; value &#61; %d&#39;, Date.now(), value);\n\n   yield flow.execute(() &#61;&gt; console.log(&#39;C&#39;));\n }).then(function() {\n   console.log(&#39;fin&#39;);\n });\n // start: 0\n // A\n // B\n // mid: 2; value &#61; 123\n // C\n // fin\n</code></pre>\n<p>Yielding a <em>rejected</em> promise will cause the rejected value to be thrown\nwithin the generator function:</p>\n<pre><code> flow.execute(function* () {\n   console.log(&#39;start: &#39; &#43; Date.now());\n   try {\n     yield promise.delayed(10).then(function() {\n       throw Error(&#39;boom&#39;);\n     });\n   } catch (ex) {\n     console.log(&#39;caught time: &#39; &#43; Date.now());\n     console.log(ex.message);\n   }\n });\n // start: 0\n // caught time: 10\n // boom\n</code></pre>\n<h1>Error Handling</h1>\n<p>ES6 promises do not require users to handle a promise rejections. This can\nresult in subtle bugs as the rejections are silently &#34;swallowed&#34; by the\nPromise class.</p>\n<pre><code> Promise.reject(Error(&#39;boom&#39;));\n // ... *crickets* ...\n</code></pre>\n<p>Selenium&#39;s promise module, on the other hand, requires that every rejection\nbe explicitly handled. When a <a href=\"promise_exports_Promise.html\">ManagedPromise</a> is\nrejected and no callbacks are defined on that promise, it is considered an\n<em>unhandled rejection</em> and reported to the active task queue. If the rejection\nremains unhandled after a single turn of the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">event loop</a> (scheduled\nwith a microtask), it will propagate up the stack.</p>\n<h2>Error Propagation</h2>\n<p>If an unhandled rejection occurs within a task function, that task&#39;s promised\nresult is rejected and all remaining subtasks are discarded:</p>\n<pre><code> flow.execute(function() {\n   // No callbacks registered on promise -&gt; unhandled rejection\n   promise.rejected(Error(&#39;boom&#39;));\n   flow.execute(function() { console.log(&#39;this will never run&#39;); });\n }).catch(function(e) {\n   console.log(e.message);\n });\n // boom\n</code></pre>\n<p>The promised results for discarded tasks are silently rejected with a\ncancellation error and existing callback chains will never fire.</p>\n<pre><code> flow.execute(function() {\n   promise.rejected(Error(&#39;boom&#39;));\n   flow.execute(function() { console.log(&#39;a&#39;); }).\n       then(function() { console.log(&#39;b&#39;); });\n }).catch(function(e) {\n   console.log(e.message);\n });\n // boom\n</code></pre>\n<p>An unhandled rejection takes precedence over a task function&#39;s returned\nresult, even if that value is another promise:</p>\n<pre><code> flow.execute(function() {\n   promise.rejected(Error(&#39;boom&#39;));\n   return flow.execute(someOtherTask);\n }).catch(function(e) {\n   console.log(e.message);\n });\n // boom\n</code></pre>\n<p>If there are multiple unhandled rejections within a task, they are packaged\nin a <a href=\"promise_exports_MultipleUnhandledRejectionError.html\"><code>MultipleUnhandledRejectionError</code></a>, which has an <code>errors</code> property\nthat is a <code>Set</code> of the recorded unhandled rejections:</p>\n<pre><code> flow.execute(function() {\n   promise.rejected(Error(&#39;boom1&#39;));\n   promise.rejected(Error(&#39;boom2&#39;));\n }).catch(function(ex) {\n   console.log(ex instanceof MultipleUnhandledRejectionError);\n   for (var e of ex.errors) {\n     console.log(e.message);\n   }\n });\n // boom1\n // boom2\n</code></pre>\n<p>When a subtask is discarded due to an unreported rejection in its parent\nframe, the existing callbacks on that task will never settle and the\ncallbacks will not be invoked. If a new callback is attached to the subtask\n<em>after</em> it has been discarded, it is handled the same as adding a callback\nto a cancelled promise: the error-callback path is invoked. This behavior is\nintended to handle cases where the user saves a reference to a task promise,\nas illustrated below.</p>\n<pre><code> var subTask;\n flow.execute(function() {\n   promise.rejected(Error(&#39;boom&#39;));\n   subTask &#61; flow.execute(function() {});\n }).catch(function(e) {\n   console.log(e.message);\n }).then(function() {\n   return subTask.then(\n       () &#61;&gt; console.log(&#39;subtask success!&#39;),\n       (e) &#61;&gt; console.log(&#39;subtask failed:\\n&#39; &#43; e));\n });\n // boom\n // subtask failed:\n // DiscardedTaskError: Task was discarded due to a previous failure: boom\n</code></pre>\n<p>When a subtask fails, its promised result is treated the same as any other\npromise: it must be handled within one turn of the rejection or the unhandled\nrejection is propagated to the parent task. This means users can catch errors\nfrom complex flows from the top level task:</p>\n<pre><code> flow.execute(function() {\n   flow.execute(function() {\n     flow.execute(function() {\n       throw Error(&#39;fail!&#39;);\n     });\n   });\n }).catch(function(e) {\n   console.log(e.message);\n });\n // fail!\n</code></pre>\n<h2>Unhandled Rejection Events</h2>\n<p>When an unhandled rejection propagates to the root of the control flow, the\nflow will emit an <strong>uncaughtException</strong> event. If no listeners are registered\non the flow, the error will be rethrown to the global error handler: an\n<strong>uncaughtException</strong> event from the\n<a href=\"https://nodejs.org/api/process.html\"><code>process</code></a> object in node, or\n<code>window.onerror</code> when running in a browser.</p>\n<p>Bottom line: you <strong><em>must</em></strong> handle rejected promises.</p>\n<h1>Promises/A&#43; Compatibility</h1>\n<p>This <code>promise</code> module is compliant with the <a href=\"https://promisesaplus.com/\">Promises/A&#43;</a> specification\nexcept for sections <code>2.2.6.1</code> and <code>2.2.6.2</code>:</p>\n<blockquote>\n<ul><li><code>then</code> may be called multiple times on the same promise.\n<ul><li>If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks\nmust execute in the order of their originating calls to <code>then</code>.</li><li>If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks\nmust execute in the order of their originating calls to <code>then</code>.</li></ul>\n</li></ul>\n</blockquote>\n<p>Specifically, the conformance tests contain the following scenario (for\nbrevity, only the fulfillment version is shown):</p>\n<pre><code> var p1 &#61; Promise.resolve();\n p1.then(function() {\n   console.log(&#39;A&#39;);\n   p1.then(() &#61;&gt; console.log(&#39;B&#39;));\n });\n p1.then(() &#61;&gt; console.log(&#39;C&#39;));\n // A\n // C\n // B\n</code></pre>\n<p>Since the <a href=\"#scheduling_callbacks\">ControlFlow</a> executes promise callbacks as\ntasks, with this module, the result would be:</p>\n<pre><code> var p2 &#61; promise.fulfilled();\n p2.then(function() {\n   console.log(&#39;A&#39;);\n   p2.then(() &#61;&gt; console.log(&#39;B&#39;);\n });\n p2.then(() &#61;&gt; console.log(&#39;C&#39;));\n // A\n // B\n // C\n</code></pre>\n"}]},"8":{"6":true},"12":[{"1":{"1":"all","2":{"1":"lib/promise.js","2":3373,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3373"},"3":{"1":[{"2":"<p>Given an array of promises, will return a promise that will be fulfilled\nwith the fulfillment values of the input array&#39;s values. If any of the\ninput array&#39;s promises are rejected, the returned promise will be rejected\nwith the same reason.</p>\n"}]}},"2":["T"],"4":[{"1":"arr","2":{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"T"}},{"4":{"1":"Promise","2":"selenium-webdriver/lib/promise.Promise","3":{"1":"promise_exports_Promise.html"},"5":[{"6":{"1":[{"4":{"1":"T"}},{"10":true}]}}]}},{"10":true}]}}]}},"3":{"1":[{"2":"<p>An array of\npromises to wait on.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"},"5":[{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"T"}},{"10":true}]}}]}}]}},"3":{"1":[{"2":"<p>A promise that is\nfulfilled with an array containing the fulfilled values of the\ninput array, or rejected with the same reason as the first\nrejected value.</p>\n"}]}}},{"1":{"1":"asap","2":{"1":"lib/promise.js","2":3374,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3374"},"3":{"1":[{"2":"<p>Invokes the appropriate callback function as soon as a promised <code>value</code> is\nresolved.</p>\n"}]}},"4":[{"1":"value","2":{"7":true},"3":{"1":[{"2":"<p>The value to observe.</p>\n"}]}},{"1":"callback","2":{"6":{"1":[{"4":{"1":"Function"}},{"10":true}]}},"3":{"1":[{"2":"<p>The function to call when the value is\nresolved successfully.</p>\n"}]}},{"1":"opt_errback","2":{"1":true,"6":{"1":[{"4":{"1":"Function"}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The function to call when the value is\nrejected.</p>\n"}]}}]},{"1":{"1":"captureStackTrace","2":{"1":"lib/promise.js","2":3375,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3375"},"3":{"1":[{"2":"<p>Generates an error to capture the current stack trace.</p>\n"}]}},"4":[{"1":"name","2":{"4":{"1":"string","4":true}},"3":{"1":[{"2":"<p>Error name for this stack trace.</p>\n"}]}},{"1":"msg","2":{"4":{"1":"string","4":true}},"3":{"1":[{"2":"<p>Message to record.</p>\n"}]}},{"1":"opt_topFn","2":{"1":true,"6":{"1":[{"4":{"1":"Function"}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The function that should appear at the top of\nthe stack; only applicable in V8.</p>\n"}]}}],"5":{"2":{"4":{"1":"Error","4":true}},"3":{"1":[{"2":"<p>The generated error.</p>\n"}]}}},{"1":{"1":"checkedNodeCall","2":{"1":"lib/promise.js","2":3376,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3376"},"3":{"1":[{"2":"<p>Wraps a function that expects a node-style callback as its final\nargument. This callback expects two arguments: an error value (which will be\nnull if the call succeeded), and the success value as the second argument.\nThe callback will the resolve or reject the returned promise, based on its\narguments.</p>\n"}]}},"4":[{"1":"fn","2":{"4":{"1":"Function"}},"3":{"1":[{"2":"<p>The function to wrap.</p>\n"}]}},{"1":"var_args","2":{"2":true,"8":true},"3":{"1":[{"2":"<p>The arguments to apply to the function, excluding the\nfinal callback.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"}}},"3":{"1":[{"2":"<p>A promise that will be resolved with the\nresult of the provided function&#39;s callback.</p>\n"}]}}},{"1":{"1":"consume","2":{"1":"lib/promise.js","2":3377,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3377"},"3":{"1":[{"2":"<p>Consumes a <code>GeneratorFunction</code>. Each time the generator yields a\npromise, this function will wait for it to be fulfilled before feeding the\nfulfilled value back into <code>next</code>. Likewise, if a yielded promise is\nrejected, the rejection error will be passed to <code>throw</code>.</p>\n<p><strong>Example 1:</strong> the Fibonacci Sequence.</p>\n<pre><code> promise.consume(function* fibonacci() {\n   var n1 &#61; 1, n2 &#61; 1;\n   for (var i &#61; 0; i &lt; 4; &#43;&#43;i) {\n     var tmp &#61; yield n1 &#43; n2;\n     n1 &#61; n2;\n     n2 &#61; tmp;\n   }\n   return n1 &#43; n2;\n }).then(function(result) {\n   console.log(result);  // 13\n });\n</code></pre>\n<p><strong>Example 2:</strong> a generator that throws.</p>\n<pre><code> promise.consume(function* () {\n   yield promise.delayed(250).then(function() {\n     throw Error(&#39;boom&#39;);\n   });\n }).catch(function(e) {\n   console.log(e.toString());  // Error: boom\n });\n</code></pre>\n"}]}},"4":[{"1":"generatorFn","2":{"4":{"1":"Function"}},"3":{"1":[{"2":"<p>The generator function to execute.</p>\n"}]}},{"1":"opt_self","2":{"1":true,"6":{"1":[{"4":{"1":"Object","4":true}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The object to use as &#34;this&#34; when invoking the\ninitial generator.</p>\n"}]}},{"1":"var_args","2":{"2":true,"7":true},"3":{"1":[{"2":"<p>Any arguments to pass to the initial generator.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"},"5":[{"8":true}]}},"3":{"1":[{"2":"<p>A promise that will resolve to the\ngenerator&#39;s final result.</p>\n"}]}},"6":[{"2":{"6":{"1":[{"4":{"1":"TypeError","4":true}},{"10":true}]}},"3":{"1":[{"2":"<p>If the given function is not a generator.</p>\n"}]}}]},{"1":{"1":"controlFlow","2":{"1":"lib/promise.js","2":3378,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3378"},"3":{}},"5":{"2":{"4":{"1":"ControlFlow","2":"selenium-webdriver/lib/promise.ControlFlow","3":{"1":"promise_exports_ControlFlow.html"}}},"3":{"1":[{"2":"<p>The currently active control flow.</p>\n"}]}}},{"1":{"1":"createFlow","2":{"1":"lib/promise.js","2":3379,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3379"},"3":{"1":[{"2":"<p>Creates a new control flow. The provided callback will be invoked as the\nfirst task within the new flow, with the flow as its sole argument. Returns\na promise that resolves to the callback result.</p>\n"}]}},"4":[{"1":"callback","2":{"3":{"3":[{"4":{"1":"ControlFlow","2":"selenium-webdriver/lib/promise.ControlFlow","3":{"1":"promise_exports_ControlFlow.html"}}}],"4":{"8":true}}},"3":{"1":[{"2":"<p>The entry point\nto the newly created flow.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"}}},"3":{"1":[{"2":"<p>A promise that resolves to the callback result.</p>\n"}]}}},{"1":{"1":"createPromise","2":{"1":"lib/promise.js","2":3380,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3380"},"3":{"1":[{"2":"<p>Creates a new promise with the given <code>resolver</code> function. If the promise\nmanager is currently enabled, the returned promise will be a\n<a href=\"promise_exports_Promise.html\">ManagedPromise</a> instance. Otherwise, it will be a native promise.</p>\n"}]}},"2":["T"],"4":[{"1":"resolver","2":{"3":{"3":[{"3":{"3":[{"1":true,"6":{}}],"4":{"8":true}}},{"3":{"3":[{"1":true,"7":true}],"4":{"8":true}}}],"4":{"8":true}}}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"},"5":[{"6":{"1":[{"4":{"1":"T"}},{"10":true}]}}]}}}},{"1":{"1":"defer","2":{"1":"lib/promise.js","2":3381,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3381"},"3":{"1":[{"2":"<p>Creates a new deferred resolver.</p>\n<p>If the promise manager is currently enabled, this function will return a\n<a href=\"promise_exports_Deferred.html\"><code>Deferred</code></a> instance. Otherwise, it will return a resolver for a\nnative promise.</p>\n"}]}},"2":["T"],"5":{"2":{"4":{"1":"Resolver","2":"selenium-webdriver/lib/promise.Resolver","3":{"1":"promise_exports_Resolver.html"},"5":[{"6":{"1":[{"4":{"1":"T"}},{"10":true}]}}]}},"3":{"1":[{"2":"<p>A new deferred resolver.</p>\n"}]}}},{"1":{"1":"delayed","2":{"1":"lib/promise.js","2":3382,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3382"},"3":{"1":[{"2":"<p>Creates a promise that will be resolved at a set time in the future.</p>\n"}]}},"4":[{"1":"ms","2":{"4":{"1":"number","4":true}},"3":{"1":[{"2":"<p>The amount of time, in milliseconds, to wait before\nresolving the promise.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"}}},"3":{"1":[{"2":"<p>The promise.</p>\n"}]}}},{"1":{"1":"filter","2":{"1":"lib/promise.js","2":3383,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3383"},"3":{"1":[{"2":"<p>Calls a function for each element in an array, and if the function returns\ntrue adds the element to a new array.</p>\n<p>If the return value of the filter function is a promise, this function\nwill wait for it to be fulfilled before determining whether to insert the\nelement into the new array.</p>\n<p>If the filter function throws or returns a rejected promise, the promise\nreturned by this function will be rejected with the same reason. Only the\nfirst failure will be reported; all subsequent errors will be silently\nignored.</p>\n"}]}},"2":["TYPE","SELF"],"4":[{"1":"arr","2":{"6":{"1":[{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}}]}},{"4":{"1":"Promise","2":"selenium-webdriver/lib/promise.Promise","3":{"1":"promise_exports_Promise.html"},"5":[{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}}]}}]}}]}},"3":{"1":[{"2":"<p>The\narray to iterator over, or a promise that will resolve to said array.</p>\n"}]}},{"1":"fn","2":{"3":{"2":{"6":{"1":[{"4":{"1":"SELF"}},{"10":true}]}},"3":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}},{"4":{"1":"number","4":true}},{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}}]}}],"4":{"6":{"1":[{"4":{"1":"boolean","4":true}},{"4":{"1":"Promise","2":"selenium-webdriver/lib/promise.Promise","3":{"1":"promise_exports_Promise.html"},"5":[{"4":{"1":"boolean","4":true}}]}},{"10":true}]}}}},"3":{"1":[{"2":"<p>The function\nto call for each element in the array.</p>\n"}]}},{"1":"opt_self","2":{"1":true,"6":{"1":[{"4":{"1":"SELF"}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The object to be used as the value of &#39;this&#39; within\n<code>fn</code>.</p>\n"}]}}]},{"1":{"1":"finally","2":{"1":"lib/promise.js","2":3384,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3384"},"3":{"1":[{"2":"<p>Registers a listener to invoke when a promise is resolved, regardless\nof whether the promise&#39;s value was successfully computed. This function\nis synonymous with the <code>finally</code> clause in a synchronous API:</p>\n<pre><code> // Synchronous API:\n try {\n   doSynchronousWork();\n } finally {\n   cleanUp();\n }\n\n // Asynchronous promise API:\n doAsynchronousWork().finally(cleanUp);\n</code></pre>\n<p><strong>Note:</strong> similar to the <code>finally</code> clause, if the registered\ncallback returns a rejected promise or throws an error, it will silently\nreplace the rejection error (if any) from this promise:</p>\n<pre><code> try {\n   throw Error(&#39;one&#39;);\n } finally {\n   throw Error(&#39;two&#39;);  // Hides Error: one\n }\n\n let p &#61; Promise.reject(Error(&#39;one&#39;));\n promise.finally(p, function() {\n   throw Error(&#39;two&#39;);  // Hides Error: one\n });\n</code></pre>\n"}]}},"2":["R"],"4":[{"1":"promise","2":{"4":{"1":"IThenable","4":true,"5":[{"8":true}]}},"3":{"1":[{"2":"<p>The promise to add the listener to.</p>\n"}]}},{"1":"callback","2":{"3":{"4":{"6":{"1":[{"4":{"1":"R"}},{"4":{"1":"IThenable","4":true,"5":[{"6":{"1":[{"4":{"1":"R"}},{"10":true}]}}]}},{"10":true}]}}}},"3":{"1":[{"2":"<p>The function to call when\nthe promise is resolved.</p>\n"}]}}],"5":{"2":{"4":{"1":"IThenable","4":true,"5":[{"6":{"1":[{"4":{"1":"R"}},{"10":true}]}}]}},"3":{"1":[{"2":"<p>A promise that will be resolved with the callback\nresult.</p>\n"}]}}},{"1":{"1":"fulfilled","2":{"1":"lib/promise.js","2":3385,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3385"},"3":{"1":[{"2":"<p>Creates a promise that has been resolved with the given value.</p>\n<p>If the promise manager is currently enabled, this function will return a\n<a href=\"promise_exports_Promise.html\">managed promise</a>. Otherwise, it will return a\nnative promise.</p>\n"}]}},"2":["T"],"4":[{"1":"opt_value","2":{"1":true,"6":{"1":[{"4":{"1":"T"}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The resolved value.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"},"5":[{"6":{"1":[{"4":{"1":"T"}},{"10":true}]}}]}},"3":{"1":[{"2":"<p>The resolved promise.</p>\n"}]}}},{"1":{"1":"fullyResolved","2":{"1":"lib/promise.js","2":3386,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3386"},"3":{"1":[{"2":"<p>Returns a promise that will be resolved with the input value in a\nfully-resolved state. If the value is an array, each element will be fully\nresolved. Likewise, if the value is an object, all keys will be fully\nresolved. In both cases, all nested arrays and objects will also be\nfully resolved.  All fields are resolved in place; the returned promise will\nresolve on <code>value</code> and not a copy.</p>\n<p>Warning: This function makes no checks against objects that contain\ncyclical references:</p>\n<pre><code> var value &#61; {};\n value[&#39;self&#39;] &#61; value;\n promise.fullyResolved(value);  // Stack overflow.\n</code></pre>\n"}]}},"4":[{"1":"value","2":{"7":true},"3":{"1":[{"2":"<p>The value to fully resolve.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"}}},"3":{"1":[{"2":"<p>A promise for a fully resolved version\nof the input value.</p>\n"}]}}},{"1":{"1":"isGenerator","2":{"1":"lib/promise.js","2":3387,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3387"},"3":{"1":[{"2":"<p>Tests is a function is a generator.</p>\n"}]}},"4":[{"1":"fn","2":{"4":{"1":"Function"}},"3":{"1":[{"2":"<p>The function to test.</p>\n"}]}}],"5":{"2":{"4":{"1":"boolean","4":true}},"3":{"1":[{"2":"<p>Whether the function is a generator.</p>\n"}]}}},{"1":{"1":"isPromise","2":{"1":"lib/promise.js","2":3388,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3388"},"3":{"1":[{"2":"<p>Determines whether a <code>value</code> should be treated as a promise.\nAny object whose &#34;then&#34; property is a function will be considered a promise.</p>\n"}]}},"4":[{"1":"value","2":{"8":true},"3":{"1":[{"2":"<p>The value to test.</p>\n"}]}}],"5":{"2":{"4":{"1":"boolean","4":true}},"3":{"1":[{"2":"<p>Whether the value is a promise.</p>\n"}]}}},{"1":{"1":"map","2":{"1":"lib/promise.js","2":3389,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3389"},"3":{"1":[{"2":"<p>Calls a function for each element in an array and inserts the result into a\nnew array, which is used as the fulfillment value of the promise returned\nby this function.</p>\n<p>If the return value of the mapping function is a promise, this function\nwill wait for it to be fulfilled before inserting it into the new array.</p>\n<p>If the mapping function throws or returns a rejected promise, the\npromise returned by this function will be rejected with the same reason.\nOnly the first failure will be reported; all subsequent errors will be\nsilently ignored.</p>\n"}]}},"2":["TYPE","SELF"],"4":[{"1":"arr","2":{"6":{"1":[{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}}]}},{"4":{"1":"Promise","2":"selenium-webdriver/lib/promise.Promise","3":{"1":"promise_exports_Promise.html"},"5":[{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}}]}}]}}]}},"3":{"1":[{"2":"<p>The\narray to iterator over, or a promise that will resolve to said array.</p>\n"}]}},{"1":"fn","2":{"3":{"2":{"6":{"1":[{"4":{"1":"SELF"}},{"10":true}]}},"3":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}},{"4":{"1":"number","4":true}},{"4":{"1":"Array","4":true,"5":[{"6":{"1":[{"4":{"1":"TYPE"}},{"10":true}]}}]}}],"4":{"8":true}}},"3":{"1":[{"2":"<p>The\nfunction to call for each element in the array. This function should\nexpect three arguments (the element, the index, and the array itself.</p>\n"}]}},{"1":"opt_self","2":{"1":true,"6":{"1":[{"4":{"1":"SELF"}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The object to be used as the value of &#39;this&#39; within\n<code>fn</code>.</p>\n"}]}}]},{"1":{"1":"rejected","2":{"1":"lib/promise.js","2":3390,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3390"},"3":{"1":[{"2":"<p>Creates a promise that has been rejected with the given reason.</p>\n<p>If the promise manager is currently enabled, this function will return a\n<a href=\"promise_exports_Promise.html\">managed promise</a>. Otherwise, it will return a\nnative promise.</p>\n"}]}},"4":[{"1":"opt_reason","2":{"1":true,"7":true},"3":{"1":[{"2":"<p>The rejection reason; may be any value, but is\nusually an Error or a string.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"},"5":[{"8":true}]}},"3":{"1":[{"2":"<p>The rejected promise.</p>\n"}]}}},{"1":{"1":"setDefaultFlow","2":{"1":"lib/promise.js","2":3391,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3391"},"3":{"1":[{"2":"<p>Changes the default flow to use when no others are active.</p>\n"}]}},"4":[{"1":"flow","2":{"4":{"1":"ControlFlow","2":"selenium-webdriver/lib/promise.ControlFlow","3":{"1":"promise_exports_ControlFlow.html"}}},"3":{"1":[{"2":"<p>The new default flow.</p>\n"}]}}],"6":[{"2":{"6":{"1":[{"4":{"1":"Error","4":true}},{"10":true}]}},"3":{"1":[{"2":"<p>If the default flow is not currently active.</p>\n"}]}}]},{"1":{"1":"when","2":{"1":"lib/promise.js","2":3392,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3392"},"3":{"1":[{"2":"<p>Registers an observer on a promised <code>value</code>, returning a new promise\nthat will be resolved when the value is. If <code>value</code> is not a promise,\nthen the return promise will be immediately resolved.</p>\n"}]},"4":{"1":[{"2":"<p>Use <code>promise.fulfilled(value).then(opt_callback, opt_errback)</code></p>\n"}]},"6":{"2":true}},"4":[{"1":"value","2":{"7":true},"3":{"1":[{"2":"<p>The value to observe.</p>\n"}]}},{"1":"opt_callback","2":{"1":true,"6":{"1":[{"4":{"1":"Function"}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The function to call when the value is\nresolved successfully.</p>\n"}]}},{"1":"opt_errback","2":{"1":true,"6":{"1":[{"4":{"1":"Function"}},{"10":true},{"9":true}]}},"3":{"1":[{"2":"<p>The function to call when the value is\nrejected.</p>\n"}]}}],"5":{"2":{"4":{"1":"Thenable","2":"selenium-webdriver/lib/promise.Thenable","3":{"1":"promise_exports_Thenable.html"}}},"3":{"1":[{"2":"<p>A new promise.</p>\n"}]}}}],"13":[{"1":{"1":"LONG_STACK_TRACES","2":{"1":"lib/promise.js","2":3411,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3411"},"3":{}},"2":{"8":true}},{"1":{"1":"USE_PROMISE_MANAGER","2":{"1":"lib/promise.js","2":3407,"3":"https://github.com/SeleniumHQ/selenium/tree/master/javascript/node/selenium-webdriver/lib/promise.js#L3407"},"3":{"1":[{"2":"<p>Indicates whether the promise manager is currently enabled. When disabled,\nattempting to use the <a href=\"promise_exports_ControlFlow.html\"><code>ControlFlow</code></a> or <a href=\"promise_exports_Promise.html\"><code>Promise</code></a>\nclasses will generate an error.</p>\n<p>The promise manager is currently enabled by default, but may be disabled\nby setting the environment variable <code>SELENIUM_PROMISE_MANAGER&#61;0</code> or by\nsetting this property to false. Setting this property will always take\nprecedence over the use of the environment variable.</p>\n"}]},"10":[{"1":[{"2":"<p><a href=\"https://github.com/SeleniumHQ/selenium/issues/2969\">https://github.com/SeleniumHQ/selenium/issues/2969</a></p>\n"}]}]},"2":{"4":{"1":"boolean","4":true}}}],"23":"promise.html","24":"selenium-webdriver/lib/promise"}]}}