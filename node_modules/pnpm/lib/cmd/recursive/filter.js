"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isSubdir = require("is-subdir");
const minimatch = require("minimatch");
const R = require("ramda");
function filterGraph(pkgGraph, packageSelectors) {
    const cherryPickedPackages = [];
    const walkedDependencies = new Set();
    const walkedDependents = new Set();
    const graph = pkgGraphToGraph(pkgGraph);
    let reversedGraph;
    for (const selector of packageSelectors) {
        const entryPackages = selector.selectBy === 'name'
            ? matchPackages(pkgGraph, selector.matcher)
            : matchPackagesByPath(pkgGraph, selector.matcher);
        switch (selector.scope) {
            case 'dependencies':
                pickSubgraph(graph, entryPackages, walkedDependencies);
                continue;
            case 'dependents':
                if (!reversedGraph) {
                    reversedGraph = reverseGraph(graph);
                }
                pickSubgraph(reversedGraph, entryPackages, walkedDependents);
                continue;
            case 'exact':
                Array.prototype.push.apply(cherryPickedPackages, entryPackages);
                continue;
        }
    }
    const walked = new Set([...walkedDependencies, ...walkedDependents]);
    cherryPickedPackages.forEach((cherryPickedPackage) => walked.add(cherryPickedPackage));
    return R.pick(Array.from(walked), pkgGraph);
}
exports.filterGraph = filterGraph;
function pkgGraphToGraph(pkgGraph) {
    const graph = {};
    Object.keys(pkgGraph).forEach((nodeId) => {
        graph[nodeId] = pkgGraph[nodeId].dependencies;
    });
    return graph;
}
function reverseGraph(graph) {
    const reversedGraph = {};
    Object.keys(graph).forEach((dependentNodeId) => {
        graph[dependentNodeId].forEach((dependencyNodeId) => {
            if (!reversedGraph[dependencyNodeId]) {
                reversedGraph[dependencyNodeId] = [dependentNodeId];
            }
            else {
                reversedGraph[dependencyNodeId].push(dependentNodeId);
            }
        });
    });
    return reversedGraph;
}
function matchPackages(graph, pattern) {
    return R.keys(graph).filter((id) => graph[id].manifest.name && minimatch(graph[id].manifest.name, pattern));
}
function matchPackagesByPath(graph, pathStartsWith) {
    return R.keys(graph).filter((location) => isSubdir(pathStartsWith, location));
}
function filterGraphByScope(graph, scope) {
    const root = matchPackages(graph, scope);
    if (!root.length)
        return {};
    const subgraphNodeIds = new Set();
    pickSubPkgGraph(graph, root, subgraphNodeIds);
    return R.pick(Array.from(subgraphNodeIds), graph);
}
exports.filterGraphByScope = filterGraphByScope;
function pickSubPkgGraph(graph, nextNodeIds, walked) {
    for (const nextNodeId of nextNodeIds) {
        if (!walked.has(nextNodeId)) {
            walked.add(nextNodeId);
            pickSubPkgGraph(graph, graph[nextNodeId].dependencies, walked);
        }
    }
}
function pickSubgraph(graph, nextNodeIds, walked) {
    for (const nextNodeId of nextNodeIds) {
        if (!walked.has(nextNodeId)) {
            walked.add(nextNodeId);
            if (graph[nextNodeId])
                pickSubgraph(graph, graph[nextNodeId], walked);
        }
    }
}
//# sourceMappingURL=filter.js.map