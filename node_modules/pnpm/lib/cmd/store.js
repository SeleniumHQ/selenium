"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("@pnpm/logger");
const store_path_1 = require("@pnpm/store-path");
const supi_1 = require("supi");
const createStoreController_1 = require("../createStoreController");
const errorTypes_1 = require("../errorTypes");
const help_1 = require("./help");
class StoreStatusError extends errorTypes_1.PnpmError {
    constructor(modified) {
        super('MODIFIED_DEPENDENCY', '');
        this.modified = modified;
    }
}
function default_1(input, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        let store;
        switch (input[0]) {
            case 'status':
                return statusCmd(opts);
            case 'prune':
                store = yield createStoreController_1.default(opts);
                const storePruneOptions = Object.assign(opts, {
                    store: store.path,
                    storeController: store.ctrl,
                });
                return supi_1.storePrune(storePruneOptions);
            case 'add':
                store = yield createStoreController_1.default(opts);
                return supi_1.storeAdd(input.slice(1), {
                    prefix: opts.prefix,
                    registry: opts.registry,
                    reporter: opts.reporter,
                    storeController: store.ctrl,
                    tag: opts.tag,
                    verifyStoreIntegrity: opts.verifyStoreIntegrity,
                });
            default:
                help_1.default(['store']);
                if (input[0]) {
                    const err = new Error(`"store ${input[0]}" is not a pnpm command. See "pnpm help store".`);
                    err['code'] = 'ERR_PNPM_INVALID_STORE_COMMAND'; // tslint:disable-line:no-string-literal
                    throw err;
                }
        }
    });
}
exports.default = default_1;
function statusCmd(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const modifiedPkgs = yield supi_1.storeStatus(Object.assign(opts, {
            store: yield store_path_1.default(opts.prefix, opts.store),
        }));
        if (!modifiedPkgs || !modifiedPkgs.length) {
            logger_1.default.info({
                message: 'Packages in the store are untouched',
                prefix: opts.prefix,
            });
            return;
        }
        throw new StoreStatusError(modifiedPkgs);
    });
}
//# sourceMappingURL=store.js.map