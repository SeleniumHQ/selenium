"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("@pnpm/logger");
const path = require("path");
const pathAbsolute = require("path-absolute");
const R = require("ramda");
const requirePnpmfile_1 = require("./requirePnpmfile");
function requireHooks(prefix, opts) {
    const globalPnpmfile = opts.globalPnpmfile && requirePnpmfile_1.default(pathAbsolute(opts.globalPnpmfile, prefix), prefix);
    let globalHooks = globalPnpmfile && globalPnpmfile.hooks;
    const pnpmFile = opts.pnpmfile && requirePnpmfile_1.default(pathAbsolute(opts.pnpmfile, prefix), prefix)
        || requirePnpmfile_1.default(path.join(prefix, 'pnpmfile.js'), prefix);
    let hooks = pnpmFile && pnpmFile.hooks;
    if (!globalHooks && !hooks)
        return {};
    globalHooks = globalHooks || {};
    hooks = hooks || {};
    const cookedHooks = {};
    if (globalHooks.readPackage || hooks.readPackage) {
        logger_1.default.info({
            message: 'readPackage hook is declared. Manifests of dependencies might get overridden',
            prefix,
        });
    }
    for (const hookName of ['readPackage', 'afterAllResolved']) {
        if (globalHooks[hookName] && hooks[hookName]) {
            const globalHookContext = createReadPackageHookContext(globalPnpmfile.filename, prefix, hookName);
            const localHookContext = createReadPackageHookContext(pnpmFile.filename, prefix, hookName);
            // the `arg` is a package manifest in case of readPackage() and a shrinkwrap object in case of afterAllResolved()
            cookedHooks[hookName] = (arg) => {
                return hooks[hookName](globalHooks[hookName](arg, globalHookContext), localHookContext);
            };
        }
        else if (globalHooks[hookName]) {
            cookedHooks[hookName] = R.partialRight(globalHooks[hookName], [createReadPackageHookContext(globalPnpmfile.filename, prefix, hookName)]);
        }
        else if (hooks[hookName]) {
            cookedHooks[hookName] = R.partialRight(hooks[hookName], [createReadPackageHookContext(pnpmFile.filename, prefix, hookName)]);
        }
    }
    return cookedHooks;
}
exports.default = requireHooks;
function createReadPackageHookContext(calledFrom, prefix, hook) {
    const readPackageHookLogger = logger_1.default('hook');
    return {
        log: (message) => readPackageHookLogger.debug({
            from: calledFrom,
            hook,
            message,
            prefix,
        }),
    };
}
//# sourceMappingURL=requireHooks.js.map