"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const archy = require("archy");
const chalk_1 = require("chalk");
const path = require("path");
const R = require("ramda");
const readPkg_1 = require("./readPkg");
const sortPackages = R.sortBy(R.path(['pkg', 'name']));
function default_1(projectPath, tree, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkg = yield readPkg_1.default(path.resolve(projectPath, 'package.json'));
        if (!opts.alwaysPrintRootPackage && !tree.length)
            return '';
        let label = '';
        if (pkg.name) {
            label += pkg.name;
            if (pkg.version) {
                label += `@${pkg.version}`;
            }
            label += ' ';
        }
        label += projectPath;
        const s = archy({
            label,
            nodes: yield toArchyTree(tree, {
                long: opts.long,
                modules: path.join(projectPath, 'node_modules'),
            }),
        });
        return s;
    });
}
exports.default = default_1;
function toArchyTree(entryNodes, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(sortPackages(entryNodes).map((node) => __awaiter(this, void 0, void 0, function* () {
            const nodes = yield toArchyTree(node.dependencies || [], opts);
            if (opts.long) {
                const pkg = yield readPkg_1.default(path.join(opts.modules, `.${node.pkg.path}`, 'node_modules', node.pkg.name, 'package.json'));
                const labelLines = [
                    printLabel(node),
                    pkg.description,
                ];
                if (pkg.repository) {
                    labelLines.push(pkg.repository.url);
                }
                if (pkg.homepage) {
                    labelLines.push(pkg.homepage);
                }
                return {
                    label: labelLines.join('\n'),
                    nodes,
                };
            }
            return {
                label: printLabel(node),
                nodes,
            };
        })));
    });
}
function printLabel(node) {
    const txt = `${node.pkg.name}@${node.pkg.version}`;
    if (node.searched) {
        return chalk_1.default.yellow.bgBlack(txt);
    }
    return txt;
}
//# sourceMappingURL=printTree.js.map