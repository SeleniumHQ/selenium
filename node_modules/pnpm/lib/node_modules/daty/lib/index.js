"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var formatoid = require("formatoid"),
    addSubtractDate = require("add-subtract-date"),
    diffDates = require("diff-dates"),
    classMethods = require("class-methods");

var Daty = function () {
    function Daty(year, month, day, hours, minutes, seconds, milliseconds) {
        _classCallCheck(this, Daty);

        switch (arguments.length) {
            case 0:
                this._ = new Date();
                break;
            case 1:
                this._ = new Date(year);
                break;
            case 2:
                this._ = new Date(year, month);
                break;
            case 3:
                this._ = new Date(year, month, day);
                break;
            case 4:
                this._ = new Date(year, month, day, hours);
                break;
            case 5:
                this._ = new Date(year, month, day, hours, minutes);
                break;
            case 6:
                this._ = new Date(year, month, day, hours, minutes, seconds);
                break;
            case 7:
                this._ = new Date(year, month, day, hours, minutes, seconds, milliseconds);
                break;
        }
    }

    /**
     * format
     * Formats the date by specifying the format.
     *
     * @name format
     * @function
     * @param {String} s The date format using the [`formatoid`](https://github.com/IonicaBizau/formatoid) supported fields or the presets:
     *
     *  - `L` : `M/D/YYYY`
     *  - `LL`: `MMMM D, YYYY`
     *  - `LLL`: `MMMM D, YYYY hh:mm A`
     *  - `LLLL`: `dddd, MMMM D, YYYY h:m A`
     *
     * If not specified, the date object will be stringified using the native `toString()` method.
     *
     * @return {String} The formated date.
     */


    _createClass(Daty, [{
        key: "format",
        value: function format(s) {
            if (!s) {
                return this.toString();
            }
            switch (s) {
                case "L":
                    return this.format("M/D/YYYY");
                case "LL":
                    return this.format("MMMM D, YYYY");
                case "LLL":
                    return this.format("MMMM D, YYYY hh:mm A");
                case "LLL":
                    return this.format("MMMM D, YYYY hh:mm A");
                case "LLLL":
                    return this.format("dddd, MMMM D, YYYY h:m A");
            }
            return formatoid(this, s);
        }

        /**
         * add
         * Adds a specified number of units to the date.
         *
         * @name add
         * @function
         * @param {String} count The number of units to subtract.
         * @param {String} what One of the units supported by [`add-subtract-date`](https://github.com/IonicaBizau/add-subtract-date).
         * @return {Daty} The `Daty` instance.
         */

    }, {
        key: "add",
        value: function add(count, what) {
            return addSubtractDate.add(this, count, what);
        }

        /**
         * subtract
         * Subtracts a specified number of units to the date.
         *
         * @name subtract
         * @function
         * @param {String} count The number of units to subtract.
         * @param {String} what One of the units supported by [`add-subtract-date`](https://github.com/IonicaBizau/add-subtract-date).
         * @return {Daty} The `Daty` instance.
         */

    }, {
        key: "subtract",
        value: function subtract(count, what) {
            return addSubtractDate.subtract(this, count, what);
        }

        /**
         * clone
         * Clones the `Daty` instance.
         *
         * @name clone
         * @function
         * @return {Daty} A new `Daty` instance that is cloned from the first one.
         */

    }, {
        key: "clone",
        value: function clone() {
            var c = new Daty();
            c.setTime(this.getTime());
            return c;
        }

        /**
         * diff
         * Makes the difference between the current instance and a specified `Daty` instance.
         *
         * @name diff
         * @function
         * @param {Daty|Date} d The date object.
         * @param {String} units One of the units supported by [`diff-dates`](https://github.com/IonicaBizau/diff-dates)
         * @return {Number} The difference result (in units).
         */

    }, {
        key: "diff",
        value: function diff(d, units) {
            return diffDates(this, d, units);
        }

        /**
         * isEqual
         * Checks if the date instance is equal to another date object.
         *
         * @name isEqual
         * @function
         * @param {Daty|Date} d The date object.
         * @return {Boolean} `true` if they are equal, `false` otherwise.
         */

    }, {
        key: "isEqual",
        value: function isEqual(d) {
            return !this.diff(d);
        }

        /**
         * isBefore
         * Checks if the date instance is before to another date object.
         *
         * @name isBefore
         * @function
         * @param {Daty|Date} d The date object.
         * @return {Boolean} `true` if the date object is before the specified date or `false` otherwise.
         */

    }, {
        key: "isBefore",
        value: function isBefore(d) {
            return this.diff(d) < 0;
        }

        /**
         * isAfter
         * Checks if the date instance is after another date object.
         *
         * @name isAfter
         * @function
         * @param {Daty|Date} d The date object.
         * @return {Boolean} `true` if the date object is after the specified date or `false` otherwise.
         */

    }, {
        key: "isAfter",
        value: function isAfter(d) {
            return this.diff(d) > 0;
        }

        /**
         * isValid
         * Checks if the date instance is valid.
         *
         * @name isAfter
         * @function
         * @return {Boolean} `true` if the date object is valid, `false` otherwise.
         */

    }, {
        key: "isValid",
        value: function isValid() {
            return !isNaN(this);
        }

        /**
         * utc
         * Useful to format the date in UTC.
         *
         * @name utc
         * @function
         * @returns {Daty} A new `Daty` instance which will be formatted in UTC output.
         */

    }, {
        key: "utc",
        value: function utc() {
            var clone = this.clone();
            clone._useUTC = true;
            return clone;
        }
    }]);

    return Daty;
}();

classMethods(Date).forEach(function (meth) {
    Daty.prototype[meth] = meth.startsWith("set") ? function () {
        this._[meth].apply(this._, arguments);
        return this;
    } : function () {
        return this._[meth].apply(this._, arguments);
    };
});

module.exports = Daty;