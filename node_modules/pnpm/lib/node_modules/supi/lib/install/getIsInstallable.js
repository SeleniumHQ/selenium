"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_loggers_1 = require("@pnpm/core-loggers");
const installChecks = require("pnpm-install-checks");
const loggers_1 = require("../loggers");
const nodeIdUtils_1 = require("../nodeIdUtils");
function getIsInstallable(pkgId, pkg, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const warn = (yield installChecks.checkPlatform({
            _id: pkgId,
            cpu: pkg.cpu,
            os: pkg.os,
        })) ||
            (yield installChecks.checkEngine({
                _id: pkgId,
                engines: pkg.engines,
            }, {
                nodeVersion: options.nodeVersion,
                pnpmVersion: options.pnpmVersion,
            }));
        if (!warn)
            return true;
        loggers_1.installCheckLogger.warn(warn);
        if (options.optional) {
            core_loggers_1.skippedOptionalDependencyLogger.debug({
                details: warn.toString(),
                package: {
                    id: pkgId,
                    name: pkg.name,
                    version: pkg.version,
                },
                parents: nodeIdToParents(options.nodeId, options.pkgByPkgId),
                prefix: options.prefix,
                reason: warn.code === 'ENOTSUP' ? 'unsupported_engine' : 'unsupported_platform',
            });
            return false;
        }
        if (options.engineStrict)
            throw warn;
        return true;
    });
}
exports.default = getIsInstallable;
function nodeIdToParents(nodeId, pkgByPkgId) {
    const pkgIds = nodeIdUtils_1.splitNodeId(nodeId).slice(2, -2);
    return pkgIds
        .map((pkgId) => {
        const pkg = pkgByPkgId[pkgId];
        return {
            id: pkg.id,
            name: pkg.name,
            version: pkg.version,
        };
    });
}
exports.nodeIdToParents = nodeIdToParents;
//# sourceMappingURL=getIsInstallable.js.map