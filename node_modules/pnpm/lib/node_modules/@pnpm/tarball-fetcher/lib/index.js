"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("@pnpm/logger");
const getCredentialsByURI = require("credentials-by-uri");
const mem = require("mem");
const fs = require("mz/fs");
const path = require("path");
const unpackStream = require("unpack-stream");
const createDownloader_1 = require("./createDownloader");
const pathTemp = require("path-temp");
const errorTypes_1 = require("./errorTypes");
const ssri = require("ssri");
function default_1(opts) {
    const download = createDownloader_1.default({
        alwaysAuth: opts.alwaysAuth || false,
        registry: opts.registry,
        ca: opts.ca,
        cert: opts.cert,
        key: opts.key,
        localAddress: opts.localAddress,
        proxy: opts.httpsProxy || opts.proxy,
        retry: {
            factor: opts.fetchRetryFactor,
            maxTimeout: opts.fetchRetryMaxtimeout,
            minTimeout: opts.fetchRetryMintimeout,
            retries: opts.fetchRetries,
        },
        // TODO: cover with tests this option
        // https://github.com/pnpm/pnpm/issues/1062
        strictSSL: typeof opts.strictSsl === 'boolean'
            ? opts.strictSsl
            : true,
        userAgent: opts.userAgent,
    });
    return {
        tarball: fetchFromTarball.bind(null, {
            fetchFromRemoteTarball: fetchFromRemoteTarball.bind(null, {
                download,
                ignoreFile: opts.ignoreFile,
                offline: opts.offline,
                getCredentialsByURI: mem((registry) => getCredentialsByURI(registry, opts.rawNpmConfig)),
            }),
            ignore: opts.ignoreFile,
        }),
    };
}
exports.default = default_1;
function fetchFromTarball(ctx, resolution, target, opts) {
    if (resolution.tarball.startsWith('file:')) {
        const tarball = path.join(opts.prefix, resolution.tarball.slice(5));
        return fetchFromLocalTarball(tarball, target, {
            ignore: ctx.ignore,
            integrity: resolution.integrity,
        });
    }
    return ctx.fetchFromRemoteTarball(target, resolution, opts);
}
function fetchFromRemoteTarball(ctx, unpackTo, dist, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield fetchFromLocalTarball(opts.cachedTarballLocation, unpackTo, {
                integrity: dist.integrity,
            });
        }
        catch (err) {
            // ignore errors for missing files or broken/partial archives
            switch (err.code) {
                case 'Z_BUF_ERROR':
                    logger_1.storeLogger.warn(`Redownloading corrupted cached tarball: ${opts.cachedTarballLocation}`);
                    break;
                case 'ENOENT':
                    break;
                default:
                    throw err;
            }
            if (ctx.offline) {
                throw new errorTypes_1.PnpmError('NO_OFFLINE_TARBALL', `Could not find ${opts.cachedTarballLocation} in local registry mirror`);
            }
            const auth = dist.registry ? ctx.getCredentialsByURI(dist.registry) : undefined;
            return yield ctx.download(dist.tarball, opts.cachedTarballLocation, {
                auth,
                ignore: ctx.ignoreFile,
                integrity: dist.integrity,
                onProgress: opts.onProgress,
                onStart: opts.onStart,
                registry: dist.registry,
                unpackTo,
            });
        }
    });
}
function fetchFromLocalTarball(tarball, dir, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const tempLocation = pathTemp(dir);
        const tarballStream = fs.createReadStream(tarball);
        try {
            const filesIndex = (yield Promise.all([
                unpackStream.local(tarballStream, tempLocation, {
                    ignore: opts.ignore,
                }),
                opts.integrity && ssri.checkStream(tarballStream, opts.integrity),
            ]))[0];
            return { filesIndex, tempLocation };
        }
        catch (err) {
            err.attempts = 1;
            err.resource = tarball;
            throw err;
        }
    });
}
//# sourceMappingURL=index.js.map