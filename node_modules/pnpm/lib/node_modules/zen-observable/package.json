{
  "_args": [
    [
      {
        "raw": "zen-observable@^0.7.0",
        "scope": null,
        "escapedName": "zen-observable",
        "name": "zen-observable",
        "rawSpec": "^0.7.0",
        "spec": ">=0.7.0 <0.8.0",
        "type": "range"
      },
      "/home/zkochan/src/pnpm/packages/pnpm/node_modules/zen-push"
    ]
  ],
  "_from": "zen-observable@>=0.7.0 <0.8.0",
  "_id": "zen-observable@0.7.1",
  "_inCache": true,
  "_location": "/zen-observable",
  "_nodeVersion": "9.3.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/zen-observable-0.7.1.tgz_1513875234096_0.5424076500348747"
  },
  "_npmUser": {
    "name": "zenparsing",
    "email": "zenparsing@gmail.com"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "zen-observable@^0.7.0",
    "scope": null,
    "escapedName": "zen-observable",
    "name": "zen-observable",
    "rawSpec": "^0.7.0",
    "spec": ">=0.7.0 <0.8.0",
    "type": "range"
  },
  "_requiredBy": [
    "/zen-push"
  ],
  "_resolved": "https://registry.npmjs.org/zen-observable/-/zen-observable-0.7.1.tgz",
  "_shasum": "f84075c0ee085594d3566e1d6454207f126411b3",
  "_shrinkwrap": null,
  "_spec": "zen-observable@^0.7.0",
  "_where": "/home/zkochan/src/pnpm/packages/pnpm/node_modules/zen-push",
  "bugs": {
    "url": "https://github.com/zenparsing/zen-observable/issues"
  },
  "dependencies": {},
  "description": "An Implementation of ES Observables",
  "devDependencies": {
    "esdown": "^1.2.8",
    "moon-unit": "^0.2.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-OI6VMSe0yeqaouIXtedC+F55Sr6r9ppS7+wTbSexkYdHbdt4ctTuPNXP/rwm7GTVI63YBc+EBT0b0tl7YnJLRg==",
    "shasum": "f84075c0ee085594d3566e1d6454207f126411b3",
    "tarball": "https://registry.npmjs.org/zen-observable/-/zen-observable-0.7.1.tgz"
  },
  "gitHead": "39bec430cd84bdc821ba500305381adb27a30f06",
  "homepage": "https://github.com/zenparsing/zen-observable",
  "license": "MIT",
  "maintainers": [
    {
      "name": "zenparsing",
      "email": "zenparsing@gmail.com"
    }
  ],
  "name": "zen-observable",
  "optionalDependencies": {},
  "readme": "# zen-observable\n\nAn implementation of [ES Observables](https://github.com/zenparsing/es-observable).\n\nRequires ES6 Promises or a Promise polyfill.\n\n## Install\n\n```sh\nnpm install zen-observable\n```\n\n## Download\n\n- [zen-observable.js](https://raw.githubusercontent.com/zenparsing/zen-observable/master/zen-observable.js)\n\n## Usage\n\nNode:\n\n```js\nvar Observable = require(\"zen-observable\");\nObservable.of(1, 2, 3).subscribe(x => console.log(x));\n```\n\nBrowser:\n\n```html\n<script src=\"zen-observable.js\"></script>\n<script>\n    Observable.of(1, 2, 3).subscribe(x => console.log(x));\n</script>\n```\n\nES Modules:\n\n```js\nimport Observable from \"zen-observable\";\nObservable.of(1, 2, 3).subscribe(x => console.log(x));\n```\n\n## API\n\n### new Observable ( subscribe )\n\n```js\nlet observable = new Observable(observer => {\n    // Emit a single value after 1 second\n    let timer = setTimeout(_=> {\n        observer.next(\"hello\");\n        observer.complete();\n    }, 1000);\n\n    // On unsubscription, cancel the timer\n    return _=> clearTimeout(timer);\n});\n```\n\nCreates a new Observable object using the specified subscriber function.  The subscriber function is called whenever the `subscribe` method of the observable object is invoked.  The subscriber function is passed an *observer* object which has the following methods:\n\n- `next(value)` Sends the next value in the sequence.\n- `error(exception)` Terminates the sequence with an exception.\n- `complete()` Terminates the sequence successfully.\n\nThe subscriber function can optionally return either a cleanup function or a subscription object.  If it returns a cleanup function, that function will be called when the subscription has closed.  If it returns a subscription object, then the subscription's `unsubscribe` method will be invoked when the subscription has closed.\n\n### Observable.of ( ...items )\n\n```js\n// Logs 1, 2, 3\nObservable.of(1, 2, 3).subscribe(x => {\n    console.log(x);\n});\n```\n\nReturns an observable which will emit each supplied argument.\n\n### Observable.from ( value )\n\n```js\nlet list = [1, 2, 3];\n\n// Iterate over an object\nObservable.from(list).subscribe(x => {\n    console.log(x);\n});\n```\n\n```js\n// Convert something \"observable\" to an Observable instance\nObservable.from(otherObservable).subscribe(x => {\n    console.log(x);\n});\n```\n\nConverts `value` to an Observable.\n\n- If `value` is an implementation of ES Observables, then it is converted to an instance of Observable as defined by this library.\n- Otherwise, it is converted to an Observable which synchronously iterates over `value`.\n\n### observable.subscribe ( observer )\n\n```js\nlet subscription = observable.subscribe({\n    next(x) { console.log(x) },\n    error(err) { console.log(`Finished with error: ${ err }`) },\n    complete() { console.log(\"Finished\") }\n})\n```\n\nSubscribes to the observable.  The `observer` argument must be an object.  It may have any of the following methods:\n\n- `start(subscription)` Receives the subscription object during initialization.\n- `next(value)` Receives the next value of the sequence.\n- `error(exception)` Receives the terminating error of the sequence.\n- `complete()` Called when the stream has completed successfully.\n\nThe subscription object can be used to cancel the stream.\n\n```js\n// Stop receiving data from the stream\nsubscription.unsubscribe();\n```\n\n## Extended API\n\n*The following methods are not yet defined by the ES Observable specification.*\n\n### observable.forEach ( callback )\n\n```js\nobservable.forEach(x => {\n    console.log(`Received value: ${ x }`);\n}).then(_=> {\n    console.log(\"Finished successfully\")\n}).catch(err => {\n    console.log(`Finished with error: ${ err }`);\n})\n```\n\nSubscribes to the observable and returns a Promise for the completion value of the stream.  The `callback` argument is called once for each value in the stream.\n\n### observable.filter ( callback )\n\n```js\nObservable.of(1, 2, 3).filter(value => {\n    return value > 2;\n}).subscribe(value => {\n    console.log(value);\n});\n// 3\n```\n\nReturns a new Observable that emits all values which pass the test implemented by the `callback` argument.\n\n### observable.map ( callback )\n\nReturns a new Observable that emits the results of calling the `callback` argument for every value in the stream.\n\n```js\nObservable.of(1, 2, 3).map(value => {\n    return value * 2;\n}).subscribe(value => {\n    console.log(value);\n});\n// 2\n// 4\n// 6\n```\n\n### observable.reduce ( callback [, initialValue] )\n\n```js\nObservable.of(0, 1, 2, 3, 4).reduce((previousValue, currentValue) => {\n    return previousValue + currentValue;\n}).subscribe(result => {\n    console.log(result);\n});\n// 10\n```\n\nReturns a new Observable that applies a function against an accumulator and each value of the stream to reduce it to a single value.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zenparsing/zen-observable.git"
  },
  "scripts": {
    "build": "esdown - src/Observable.js zen-observable.js -g '*'",
    "prepublishOnly": "npm run build",
    "test": "esdown test"
  },
  "version": "0.7.1"
}
